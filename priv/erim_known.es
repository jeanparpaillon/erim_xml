#!/usr/bin/env escript
%% -*- erlang -*-
%%
%% Copyright Jean Parpaillon 2014. All Rights Reserved.
%%
%% The contents of this file are subject to the Erlang Public License,
%% Version 1.1, (the "License"); you may not use this file except in
%% compliance with the License. You should have received a copy of the
%% Erlang Public License along with this software. If not, it can be
%% retrieved online at http://www.erlang.org/.
%%
%% Software distributed under the License is distributed on an "AS IS"
%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
%% the License for the specific language governing rights and limitations
%% under the License.

%% @author Jean Parpaillon <jean.parpaillon@free.fr>

main([ Type, OutType, In  ]) ->
    case OutType of
	"erl" ->
	    generate(erl, Type, read(In), standard_io);
	"hrl" ->
	    generate(hrl, Type, read(In), standard_io);
	_ ->
	    io:fwrite(standard_err, usage())
    end;
main(_) ->
    io:fwrite(standard_err, usage()).

usage() ->
    io_lib:format("Usage: ~p {nss|attrs|elems} {erl|hrl} file.in~n",
		  [filename:basename(escript:script_name())]).

generate(hrl, "nss", Terms, Out) ->
    write(terms_to_hrl("XML_KNOWN_NSS", Terms), Out);
generate(erl, "nss", Terms, Out) ->
    write(terms_to_erl("erim_known_nss", "ns_as_list", Terms), Out);
generate(hrl, "attrs", Terms, Out) ->
    write(terms_to_hrl("XML_KNOWN_ATTRS", Terms), Out);
generate(erl, "attrs", Terms, Out) ->
    write(terms_to_erl("erim_known_attrs", "attr_as_list", Terms), Out);
generate(hrl, "elems", Terms, Out) ->
    write(terms_to_hrl("XML_KNOWN_ELEMS", Terms), Out);
generate(erl, "elems", Terms, Out) ->
    write(terms_to_erl("erim_known_elems", "elem_as_list", Terms), Out);
generate(_,_,_, _) ->
    throw({error, invalid_args}).

write(Str, standard_io) ->
    write_dev(Str, standard_io);
write(Str, Outfile) ->
    case file:open(Outfile, [write]) of
	{ok, Io} ->
	    write_dev(Str, Io);
	{error, Err} ->
	    io:fwrite(standard_err, "IO Error: ~p~n", [Err])
    end.

write_dev(Str, Dev) ->
    io:fwrite(Dev, "% Generated by ~p on ~s~n", [filename:basename(escript:script_name()),
						 time_to_str(erlang:now())]),
    io:fwrite(Dev, Str, []).

terms_to_erl(Mod, Fun, Terms) ->
    S = [ io_lib:format("-module(~s).~n"
			"-export([~s/1]).~n~n", [Mod, Fun]) ],
    S2 = sets:fold(fun (NSbin, Acc) ->
			   NS = to_atom(NSbin),
			   [ io_lib:format("~s('~s') -> \"~s\";~n", [Fun, NS, NS]) | Acc ]
		   end, S, Terms),
    S3 = [ io_lib:format("~s(undefined) -> \"\";~n", [Fun]) | S2 ],
    S4 = [ io_lib:format("~s(A) when is_atom(A) -> atom_to_list(A);~n", [Fun]) | S3 ],
    S5 = [ io_lib:format("~s(S) when is_list(S) -> S.~n~n", [Fun]) | S4 ],
    lists:reverse(S5).

terms_to_hrl(Def, Terms) ->
    List = lists:reverse([ '$end_of_table' | [ to_atom(Term) || Term <- sets:to_list(Terms) ] ]),
    io_lib:format("-define(~s,~n"
		  "        ~p).~n~n", [ Def, List ]).

read(Src) ->
    {ok, Bin} = file:read_file(Src),
    read_line(Bin, <<>>, sets:new()).

read_line(<<>>, _, T) ->
    T;
read_line(<< $#, Rest/bits >>, <<>>, T) ->
    read_comment(Rest, <<>>, T);
read_line(<< $\n, Rest/bits >>, <<>>, T) ->
    read_line(Rest, <<>>, T);
read_line(<< C, Rest/bits >>, A, T) ->
    case C of
	$\n -> read_line(Rest, <<>>, sets:add_element(A, T));
	$\s -> read_line(Rest, A, T);
	$\t -> read_line(Rest, A, T);
	C -> read_line(Rest, << A/binary, C >>, T)
    end.

read_comment(<< $\n, Rest/bits >>, A, T) ->
    read_line(Rest, A, T);
read_comment(<< _, Rest/bits >>, A, T) ->
    read_comment(Rest, A, T).

time_to_str(Time) ->
    {{Y,Mo,D},{H,M,S}} = calendar:now_to_datetime(Time),
    io_lib:format("~p-~p-~p, ~p:~p:~p UTC", [Y, Mo, D, H, M, S]).

to_atom(Bin) when is_binary(Bin) ->
    binary_to_atom(Bin, utf8).
